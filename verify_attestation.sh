#!/usr/bin/env bash
#
# verify_attestation.sh
#
# Verifies TPM quote signature and measured state for a SONiC node.
# - Uses TPM2 tools (tpm2_checkquote) to validate the quote signature with the AK public key
# - Compares PCR values AND component hashes against a reference database
#
# Requirements:
#   - tpm2-tools, jq, openssl, awk, sed, coreutils
#   - AK public key exported at setup time (see notes below)
#
# Usage:
#   verify_attestation.sh init
#   verify_attestation.sh add-ref <component> <subcomponent> <sha256_hex> "<description>"
#   verify_attestation.sh list-refs [filter]
#   verify_attestation.sh verify <attestation_dir>
#   verify_attestation.sh trust-decision <attestation_dir>
#
# Attestation directory must contain (generated by generate_quote.sh / measure_system.sh):
#   - quote.msg            # TPM attested structure (TPMS_ATTEST)
#   - quote.sig            # Signature over quote.msg by AK
#   - quote.pcr            # Text/YAML with selected PCRs and digests emitted by tpm2_quote -o
#   - nonce.txt            # Nonce used for freshness (hex)
#   - measurements.json    # Collected component hashes (optional but recommended)
#   - ak.pub               # (optional) AK public key for this attester; if missing, global ak.pub is used
#
# Global AK pub fallback:
#   - /etc/sonic/attestation/keys/ak.pub
#
# Reference DB:
#   - /var/lib/sonic/attestation/reference_values.db
#     Each line: component:subcomponent:sha256hex:description
#     Special PCR entries use component 'pcr' and subcomponent 'sha256:<index>'
#
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"

# ---------- Config (override via /etc/sonic/attestation/attestation.conf) ----------
TPM_TCTI_DEFAULT="device:/dev/tpmrm0"   # for hardware TPM; swtpm users often export env externally
CONF_FILE="/etc/sonic/attestation/attestation.conf"

AK_GLOBAL="/etc/sonic/attestation/keys/ak.pub"
REF_DB="/var/lib/sonic/attestation/reference_values.db"
STATE_DIR="/var/lib/sonic/attestation"
LOG_FILE="/var/log/sonic/attestation.log"

# Load config if present
if [[ -f "$CONF_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CONF_FILE"
fi

# Defaults if not in conf
: "${TPM2TOOLS_TCTI:=${TPM_TCTI_DEFAULT}}"
export TPM2TOOLS_TCTI

mkdir -p "$(dirname "$LOG_FILE")" "$(dirname "$REF_DB")"

log() { printf '[%s] %s\n' "$(date --iso-8601=seconds)" "$*" | tee -a "$LOG_FILE" >&2; }
die() { log "ERROR: $*"; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

need tpm2_checkquote
need awk
need sed
need grep

usage() {
  cat <<EOF
$SCRIPT_NAME

Commands:
  init
      Create the reference DB if missing.

  add-ref <component> <subcomponent> <sha256_hex> "<description>"
      Add or update a reference entry. For PCRs, use:
        component = pcr
        subcomponent = sha256:<index>     e.g., sha256:9

  list-refs [filter]
      Print reference entries; optional substring filter.

  verify <attestation_dir>
      Verify quote signature (with AK) and compare PCRs and component hashes.

  trust-decision <attestation_dir>
      Return "TRUSTED" or "UNTRUSTED" based on the last verify result file.

Files expected under <attestation_dir>:
  quote.msg, quote.sig, quote.pcr, nonce.txt, measurements.json (optional), ak.pub (optional)

Environment:
  TPM2TOOLS_TCTI=${TPM2TOOLS_TCTI}
EOF
}

ensure_refdb() {
  [[ -f "$REF_DB" ]] || { touch "$REF_DB"; chmod 0644 "$REF_DB"; }
}

cmd_init() {
  ensure_refdb
  log "Reference DB initialized at $REF_DB"
}

cmd_add_ref() {
  ensure_refdb
  [[ $# -ge 4 ]] || die "add-ref needs 4 args"
  local comp="$1" sub="$2" hash="$3" desc="$4"

  # Basic sanity
  [[ "$hash" =~ ^[0-9a-fA-F]{64}$ ]] || die "Hash must be 64 hex chars (sha256)."
  # Remove existing identical comp:sub if any, then append
  local tmp
  tmp="$(mktemp)"
  grep -v -E "^${comp}:${sub}:" "$REF_DB" > "$tmp" || true
  printf "%s:%s:%s:%s\n" "$comp" "$sub" "$(echo "$hash" | tr '[:upper:]' '[:lower:]')" "$desc" >> "$tmp"
  mv "$tmp" "$REF_DB"
  log "Added/updated reference: ${comp}:${sub}"
}

cmd_list_refs() {
  ensure_refdb
  local filter="${1:-}"
  if [[ -z "$filter" ]]; then
    cat "$REF_DB"
  else
    grep -i -- "$filter" "$REF_DB" || true
  fi
}

# Helper: read key:value from DB
ref_lookup() {
  local comp="$1" sub="$2"
  awk -F: -v c="$comp" -v s="$sub" 'tolower($1)==tolower(c) && tolower($2)==tolower(s){print tolower($3); exit 0}' "$REF_DB"
}

# Extract PCR map from a quote.pcr produced by tpm2_quote -o
# Supports common YAML-ish or "sha256:<idx> : <hex>" formats
parse_pcr_file() {
  # prints lines "sha256:<index>=<hex>"
  sed -n -E '
    s/^[[:space:]]*sha256:[[:space:]]*([0-9]+)[[:space:]]*:[[:space:]]*([0-9a-fA-F]+)[[:space:]]*$/sha256:\1=\2/p;
    s/^[[:space:]]*([0-9]+)[[:space:]]*:[[:space:]]*([0-9a-fA-F]+)[[:space:]]*$/sha256:\1=\2/p;
  ' "$1" | awk -F= '{printf "%s=%s\n", $1, tolower($2)}'
}

# Verify quote signature with AK public key
verify_quote_signature() {
  local attest_dir="$1"

  local msg="$attest_dir/quote.msg"
  local sig="$attest_dir/quote.sig"
  local pcr="$attest_dir/quote.pcr"
  local nonce_file="$attest_dir/nonce.txt"

  [[ -f "$msg" ]] || die "Missing $msg"
  [[ -f "$sig" ]] || die "Missing $sig"
  [[ -f "$pcr" ]] || die "Missing $pcr"

  local ak_pub=""
  if [[ -f "$attest_dir/ak.pub" ]]; then
    ak_pub="$attest_dir/ak.pub"
  else
    [[ -f "$AK_GLOBAL" ]] || die "AK public key not found (looked for $attest_dir/ak.pub and $AK_GLOBAL)"
    ak_pub="$AK_GLOBAL"
  fi

  local nonce_arg=()
  if [[ -f "$nonce_file" ]]; then
    local nonce_hex
    nonce_hex="$(tr -d ' \t\r\n' < "$nonce_file")"
    [[ "$nonce_hex" =~ ^[0-9a-fA-F]+$ ]] || die "nonce.txt must contain a hex nonce"
    nonce_arg=(-q "$nonce_hex")
  fi

  # -g sha256 is typical for PCR banks used
  if tpm2_checkquote -u "$ak_pub" -m "$msg" -s "$sig" -f "$pcr" -g sha256 "${nonce_arg[@]}" >/dev/null 2>&1; then
    log "Quote signature verification: OK"
    return 0
  else
    die "Quote signature verification FAILED (tpm2_checkquote)."
  fi
}

# Verify PCRs against reference DB entries of kind pcr:sha256:<index>
verify_pcrs_against_ref() {
  local pcr_file="$1"
  local -i failures=0
  local line
  while IFS= read -r line; do
    # line example: sha256:9=abcdef...
    local key="${line%%=*}"
    local val="${line#*=}"
    local idx="${key#sha256:}"
    # look up expected
    local expected
    expected="$(ref_lookup "pcr" "sha256:${idx}")" || true
    if [[ -z "$expected" ]]; then
      log "PCR sha256:${idx}: no reference set -> SKIP comparison"
      continue
    fi
    if [[ "$expected" != "$val" ]]; then
      log "PCR sha256:${idx}: MISMATCH expected=$expected got=$val"
      failures+=1
    else
      log "PCR sha256:${idx}: OK"
    fi
  done < <(parse_pcr_file "$pcr_file")
  return $failures
}

# Verify component hashes from measurements.json against reference DB
verify_measurements_against_ref() {
  local measurements_json="$1"
  [[ -f "$measurements_json" ]] || { log "measurements.json not found -> SKIP component comparison"; return 0; }

  need jq
  local -i failures=0

  # Expect a JSON like:
  # {
  #   "kernel": {"version":"<sha256>", "config":"<sha256>"},
  #   "sonic": {"config_db":"<sha256>"},
  #   ...
  # }
  local comps
  comps="$(jq -r 'keys[]' "$measurements_json")"
  for c in $comps; do
    local subs
    subs="$(jq -r --arg c "$c" '.[$c] | keys[]' "$measurements_json")"
    for s in $subs; do
      local h
      h="$(jq -r --arg c "$c" --arg s "$s" '.[$c][$s]' "$measurements_json" | tr '[:upper:]' '[:lower:]')"
      if ! [[ "$h" =~ ^[0-9a-fA-F]{64}$ ]]; then
        log "Component $c:$s has non-sha256 or empty value -> SKIP"
        continue
      fi
      local expected
      expected="$(ref_lookup "$c" "$s")" || true
      if [[ -z "$expected" ]]; then
        log "No reference for $c:$s -> SKIP comparison"
        continue
      fi
      if [[ "$expected" != "$h" ]]; then
        log "Component $c:$s: MISMATCH expected=$expected got=$h"
        failures+=1
      else
        log "Component $c:$s: OK"
      fi
    done
  done

  return $failures
}

cmd_verify() {
  ensure_refdb
  [[ $# -ge 1 ]] || die "verify needs <attestation_dir>"
  local dir="$1"
  [[ -d "$dir" ]] || die "Not a directory: $dir"

  log "=== Verifying attestation in $dir ==="

  verify_quote_signature "$dir"

  local pcr_fail=0 meas_fail=0

  if verify_pcrs_against_ref "$dir/quote.pcr"; then
    : # OK
  else
    pcr_fail=$?
    log "PCR verification had $pcr_fail mismatches."
  fi

  if verify_measurements_against_ref "$dir/measurements.json"; then
    : # OK
  else
    meas_fail=$?
    log "Measurements verification had $meas_fail mismatches."
  fi

  local rc=0
  if (( pcr_fail > 0 || meas_fail > 0 )); then
    rc=1
  fi

  # Persist a decision artifact for trust-decision
  local verdict_file="$dir/.verify_result"
  if (( rc == 0 )); then
    echo "OK" > "$verdict_file"
    log "VERIFICATION RESULT: OK"
  else
    echo "FAIL" > "$verdict_file"
    log "VERIFICATION RESULT: FAIL"
  fi

  return $rc
}

cmd_trust_decision() {
  [[ $# -ge 1 ]] || die "trust-decision needs <attestation_dir>"
  local dir="$1"
  local verdict_file="$dir/.verify_result"
  if [[ ! -f "$verdict_file" ]]; then
    # Try verifying now
    if "$0" verify "$dir"; then
      echo "TRUSTED"
      return 0
    else
      echo "UNTRUSTED"
      return 1
    fi
  fi
  if grep -q '^OK$' "$verdict_file"; then
    echo "TRUSTED"
    return 0
  else
    echo "UNTRUSTED"
    return 1
  fi
}

# -------- Main --------
cmd="${1:-}"
case "$cmd" in
  init) shift; cmd_init "$@";;
  add-ref) shift; cmd_add_ref "$@";;
  list-refs) shift; cmd_list_refs "${1:-}";;
  verify) shift; cmd_verify "$@";;
  trust-decision) shift; cmd_trust_decision "$@";;
  -h|--help|"") usage;;
  *) die "Unknown command: $cmd";;
esac
